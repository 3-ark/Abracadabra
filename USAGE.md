# 魔曰 细节和使用指南

[<img src="https://img.shields.io/badge/license-AIPL%201.1-yellow"/>](LICENSE.md)

**Abracadabra(魔曰)** 是一个用于加密短文本/链接的工具。

如果想直接阅读使用指南，请跳到 [**使用指南**](#最佳操作实践)

## 密本安全

魔曰的密本不同于任何同类型的工具，它由数百个《通用规范汉字表》中的一级字和二级字构成，也有一些非常常见的 **日本和制汉字(Kanji)**，比如 **桜(Sakura)**；没有任何让人眼花缭乱的诡异汉字。

## 随机性

相同原文，相同密钥的情况下，本程序的加密结果随机性很高，不同于其他类似工具的单一密文。

随机性可以显著增强本工具的安全性，抵抗各种攻击，

在明文和密钥都一样的情况下，每次加密出来的密文可以说是**完全不同**。

### 传统加密随机性

第一重随机性来源于 AES-256-CTR 的两字节初始化向量，能够提供 256×256 共 65536 种可能密文。

第二重随机性则来源于密本(不考虑转轮)，每个字符至少有 10 种加密可能，即第二重随机性为 10^N。

最终的密文可能性为 65536*10^N，N为Base64字符串长度(近似正比于原文字节数)。

### 仿真加密随机性

第一重随机性来源于 AES-256-CTR 的两字节初始化向量，能够提供 256×256 共 65536 种可能密文。

第二重随机性则来源于密本和句式(不考虑转轮)，每个字符至少有 3 种加密可能，即第二重随机性为 3^N。

句式本身引入的虚词也提供相当的随机性。

不考虑句式虚词，最终的密文可能性为 65536*3^N，考虑虚词则更高。

## 加密安全

### AES-256

AES-256 是业内公认的安全加密算法，久经考验。

魔曰使用 AES-256-CTR 作为密文的核心加密方案，使得密文的安全性有基本的保证。

唯一的不足之处在于初始化向量(IV)的长度，标准长度是 16 字节，但是由于本项目的密文长度必须尽可能地短，便把 IV 长度压缩至两个字节，提供 65536 种随机性，配合转轮混淆，在大多数情况下足够安全。

由于IV(nounce)随机性被削减，可能发生CTR流密钥重用问题。

**如果没有混淆操作**，相同密钥加密出的密文有 N(相同密钥加密的有效密文数量)/65535 的可能导致明文的异或值泄露。

密钥参与的古典转轮混淆很大程度上避免了此问题，如果你在意安全性，请尽可能使用不同的密钥来加密。

### 转轮混淆

有关转轮混淆的细节，请见 [**Issue#30**](https://github.com/SheepChef/Abracadabra/issues/30)

## 传统加密标志位

标志位用来简化加解密操作流程，程序识别到加密标志位便会自动解密，无需用户手动指定解密，提高便利性。

没有标志位的密文，在自动模式下将默认被再次加密，你需要手动指定强制解密。

## 文言仿真器

文言仿真，本质上是一种数据特征处理手段。

仿真密文“载荷子”采用单字。载荷子和提前编写好的句式模板构成一个语块，每个句式都有一个固定载荷容量。

在生成密文的时候，会按照和传统一致的策略，对数据进行压缩，加密。然后使用一个特定算法来选取句式。

分析句式中所有有效载荷的属性(形容词，名词，动词等)和顺序，然后配合三重轮转来匹配选取载荷子，配合标点符号(可选)，最终组成一个合法密文。

生成出的密文符合古文语法，上下文有似是而非的逻辑关系。

有关文言仿真的更多细节，请见 [**Issue#60**](https://github.com/SheepChef/Abracadabra/issues/60)

## 压缩算法

项目使用专门针对短文本优化的 [**Unishox2**](https://github.com/siara-cc/Unishox2) 压缩算法，避免了通用压缩算法(如 GZIP 等)文件头过重的问题。

针对链接和常见域名编排了字典，有效提高特定链接(例如网盘链接)的压缩效率。

## 错误校验

项目使用轻量化的 [**卢恩算法**](https://zh.wikipedia.org/zh-cn/%E5%8D%A2%E6%81%A9%E7%AE%97%E6%B3%95)(US2950048， ISO/IEC 7812-1) 来对解密结果做简单校验，能够检出 70%的错误。

卢恩算法比起 Hmac 和 AES-GCM，安全性稍弱，但它十分轻量，校验位仅占一个字节。

## 跨平台

魔曰加密是一个跨平台的项目，以 JavaScript 实现，提供 WebAssembly 模块。

目前项目的 Demo 页已经开源，并且我(开发者)自认为它制作精美，拥有完善的配套功能和美观的视觉体验，且支持 PWA，可以安装到本地离线使用。

Demo 页使用 Vue 构建，你可以随时下载源码，在你喜欢的地方轻易地部署它。

## 最佳操作实践

### 文言仿真加密

下面列出一些情况下的最佳实践。

#### 仿真随机性

用户在菜单中可以通过滑条来选择句式的随机程度。
如果想增强句子逻辑性，那么请调整至"长句优先"，挑选句式的时候会优先使用最长的可用句，但加密随机性可能受影响。

如果想要更随机，语块长短不一的密文，则推荐选择“适中”或更高。

#### 通顺

如果嫌生成的句子过于生硬，不妨多次尝试生成(多点几下加密)，选择一个看起来最好的密文。  
只要密钥和原文相同，生成出的所有密文均可以正常解密。

#### 逻辑最佳密文

如果想要尽可能生成逻辑上最佳的密文，请打开**逻辑**模式。  
然后将随机性滑条拖到最左侧(0)。

如此可以尽量使密文由尽可能多的转折/逻辑复合句式构成。  
能够达到最大程度的，逻辑意义上的以假乱真。

#### 长度最佳密文

如果想要尽可能生成短的密文，请打开**骈文**模式。  
然后将随机性滑条拖到最左侧(0)。

如此可以尽量使密文由尽可能多的四字/五字骈文句式构成。  
在增强密文文言风格的同时，提升密文的载荷比，使密文缩短。

#### 混合模式

如果不作任何特殊设置，仿真算法会参考概率随机组句。  
如此生成的密文随机性更强，适合一般情况下的使用。

#### 密文的合适长度

不建议生成过长的密文。

过长的密文(>150字)，在逻辑上难以形成链条，在句式上可能出现雷同，在字频上可能出现特征。
因此不推荐将大段文章丢进加密器加密。

#### 与上下文搭配

合适的做法是将加密出来的文言文与上下文搭配。  
这么做可以抵抗多种攻击，也让BERT之类的模型难以对文本进行分类。

---

### 传统乱字加密

下面列出一些情况下的最佳实践。

#### 安全优先

如果你需要最高的安全性，则在加密时设置一个尽可能长和复杂的密码。

最好勾选“去除标志”，来提升密文随机性。

解密时将需要对方勾选强制解密。

#### 效率优先

你可以不填密码，这将会使程序自动用内部的默认密码`ABRACADABRA`加/解密。

把密文的识别交给标志位，这么做可以让他人很方便地解密。